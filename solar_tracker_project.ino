#include <Servo.h>
Servo pan;    // create servo object to control the yaw servo
Servo tilt;  // create servo object to control the pitch servo

/*---------------------------------------- CONSTANTS ----------------------------------------*/
// Modes
#define DEBUG_MODE_ON 0
#define DAQ_MODE_ON 1

// Hill-climbing algorithm: constants
#define MIN_DIFF 30
#define STEP_DIVIDER 30
#define ANALOG_READ_DELAY 100

// Number of measurements for the light
// intiensities to compute the average from
#define NO_MEASUREMENTS 5

// Pins
int pinPhotoResistorS = A1;
int pinPhotoResistorN = A2;
int pinPhotoResistorE = A3;
int pinPhotoResistorW = A0;

int solarPanelVoltagePin = A7;

int panPin = 2;
int tiltPin = 4;

// Motor constants
#define MIN_TILT 5
#define MAX_TILT 85
#define MIN_PAN 5
#define MAX_PAN 175

// increments for broad search
#define TILT_INC_BROAD 5
#define PAN_INC_BROAD 5
// increments for restricted search
#define TILT_INC_RESTR 5
#define PAN_INC_RESTR 2
// to define restricted search area
#define RESTR_SEARCH_AREA_TILT 20
#define RESTR_SEARCH_AREA_PAN 30

/*------------------------------------- Application State -------------------------------------*/

// Data structures for the application's state
struct MotorPositions {
  int panAngle = 90;
  int tiltAngle = 90;
};

struct LightIntensityData {
  int S = 0;
  int N = 0;
  int E = 0;
  int W = 0;
};

//application working mode
enum Mode {
  sensorMode,
  searchMode,
  lowPowerMode
};

Mode mode = searchMode;

LightIntensityData lightIntData;
MotorPositions motorPos, prevMotorPos, maxVoltageMotorPos;
double voltage = 0.0;
double max_voltage = 0.0;

// Loop counter, for the DAQ verification purposes
int loop_counter = 0;

//used to perform searches at a specified interval
unsigned long previousMillis = 0;
const long interval = 30000; // 30 second interval bteween restricted searches

//used to initalize the search mode with a broad search
bool initialize_broad_search = true;

/*-------------------------------------------- Setup --------------------------------------------*/
void setup() {

  // setup pins for photoresistors
  pinMode(pinPhotoResistorN, INPUT);
  pinMode(pinPhotoResistorS, INPUT);
  pinMode(pinPhotoResistorE, INPUT);
  pinMode(pinPhotoResistorW, INPUT);

  // setup the pin for the solar panel
  pinMode(solarPanelVoltagePin, INPUT);

  // setup pins for servo motors
  pan.attach(panPin);   // attaches the servo on pin 2 to the servo object
  tilt.attach(tiltPin);  // attaches the servo on pin 3 to the servo object

  if (DEBUG_MODE_ON) {
    DebugModeSetup();
  } else if (DAQ_MODE_ON) {
    DAQModeSetup();
  }
}

/*--------------------------------------------- Loop ---------------------------------------------*/
void loop() {
  loop_counter++;

  // reading the photoresistor values (introduces a delay in the loop)
  lightIntData = readLightIntensities();
  // measure voltage generated by the solar panel
  voltage = readSolarPanelVoltage();

  switch (mode) {
    case sensorMode : {
        // finding the new motor positions
        prevMotorPos = motorPos;
        motorPos = computeNewMotorAngles(prevMotorPos, lightIntData);
        // move motors to the new angles, if a change occured
        updateMotorAngles();
        outputData();
        break;
      }
    case searchMode : {
        if (initialize_broad_search) {
          initialize_broad_search = false;
          maxVoltageMotorPos = performSearch(MIN_PAN, MIN_TILT, MAX_PAN, MAX_TILT, TILT_INC_BROAD, PAN_INC_BROAD);
          motorPos = maxVoltageMotorPos;
          updateMotorAngles();
          outputData();
          previousMillis = millis();
        } else {
          unsigned long currentMillis = millis(); // used to have an interval of time between searches
          if (currentMillis - previousMillis >= interval) {
            previousMillis = currentMillis;
            // we will make a more restricted search since we supppose the light won't move very much
            // from the initial position
            maxVoltageMotorPos = performSearch(motorPos.panAngle - RESTR_SEARCH_AREA_PAN, 
                                              motorPos.tiltAngle - RESTR_SEARCH_AREA_TILT, 
                                              motorPos.panAngle + RESTR_SEARCH_AREA_PAN, 
                                              motorPos.tiltAngle + RESTR_SEARCH_AREA_TILT, TILT_INC_RESTR, PAN_INC_RESTR);
            motorPos = maxVoltageMotorPos;
            updateMotorAngles();
            outputData();
          }
        }
        break;
      }
  }
}

/*--------------------------------------- Reading the Sensors ---------------------------------------*/
LightIntensityData readLightIntensities() {
  LightIntensityData result;

  int lightIntensityS, lightIntensityN, lightIntensityE, lightIntensityW;

  for (int i = 0; i < NO_MEASUREMENTS; i++) {
    lightIntensityS = analogRead(pinPhotoResistorS);
    delay(ANALOG_READ_DELAY);
    lightIntensityN = analogRead(pinPhotoResistorN);
    delay(ANALOG_READ_DELAY);
    lightIntensityE = analogRead(pinPhotoResistorE);
    delay(ANALOG_READ_DELAY);
    lightIntensityW = analogRead(pinPhotoResistorW);
    delay(ANALOG_READ_DELAY);

    result.S += lightIntensityS;
    result.N += lightIntensityN;
    result.E += lightIntensityE;
    result.W += lightIntensityW;
  }

  result.S /= NO_MEASUREMENTS;
  result.E /= NO_MEASUREMENTS;
  result.W /= NO_MEASUREMENTS;
  result.N /= NO_MEASUREMENTS;

  return result;
}

double readSolarPanelVoltage() {
  int digitalValue = analogRead(solarPanelVoltagePin);
  double analogVoltageValue = digitalValue * 5.0 / 1023.0;
  return analogVoltageValue;
}

/*------------------------------------ Repositioning the motors -----------------------------------*/
MotorPositions computeNewMotorAngles(MotorPositions prevPos, LightIntensityData lightIntData) {
  MotorPositions resultPos;
  resultPos.tiltAngle = prevPos.tiltAngle;
  resultPos.panAngle = prevPos.panAngle;

  // compute new angles
  int SNdirectionDiff = lightIntData.S - lightIntData.N;
  if (abs(SNdirectionDiff) >= MIN_DIFF) {
    resultPos.tiltAngle = max(MIN_TILT, min(MAX_TILT, prevPos.tiltAngle + SNdirectionDiff / STEP_DIVIDER));
  }

  int EWdirectionDiff = lightIntData.E - lightIntData.W;
  if (abs(EWdirectionDiff) >= MIN_DIFF) {
    resultPos.panAngle = max(MIN_PAN, min(MAX_PAN, prevPos.panAngle + EWdirectionDiff / STEP_DIVIDER));
  }

  return resultPos;
}

MotorPositions performSearch(int pan_start, int tilt_start, int pan_end, int tilt_end, int tilt_increment, int pan_increment) {
  maxVoltageMotorPos.panAngle = pan_start;
  maxVoltageMotorPos.tiltAngle = tilt_start;
  max_voltage = 0.0;
  bool moving_pan_left_to_right = true;
  bool continue_moving_pan = true;
  int pan_pos = pan_start;

  //make sure not to exceed the limits
  if (tilt_start < MIN_TILT) {
    tilt_start = MIN_TILT;
  }
  if (tilt_end > MAX_TILT) {
    tilt_end = MAX_TILT;
  }
  if (pan_start < MIN_PAN) {
    pan_start = MIN_PAN;
  }
  if (pan_end > MAX_PAN) {
    pan_end = MAX_PAN;
  }

  for (int tilt_pos = tilt_start; tilt_pos <= tilt_end; tilt_pos += tilt_increment) {
    tilt.write(tilt_pos);
    while (continue_moving_pan) {
      pan.write(pan_pos);
      double current_voltage = readSolarPanelVoltage();

      //print
      debugForMode2();

      //identify is this is the max voltage
      if (current_voltage > max_voltage) {
        maxVoltageMotorPos.panAngle = pan_pos;
        maxVoltageMotorPos.tiltAngle = tilt_pos;
        max_voltage = current_voltage;
      }
      if (moving_pan_left_to_right) {
        pan_pos += pan_increment;
        if (pan_pos >= pan_end) {
          continue_moving_pan = false;
        }
      } else { //once the pan reaches far right we will move from right to left to use less resources
        pan_pos -= pan_increment;
        if (pan_pos <= pan_start) {
          continue_moving_pan = false;
        }
      }
      delay(50); // delay between next move and measure
    }
    moving_pan_left_to_right = !moving_pan_left_to_right;
    continue_moving_pan = true;
  }
  return maxVoltageMotorPos;
}

void updateMotorAngles() {
  // move motors to the new angles, if a change occured
  if (motorPos.panAngle != prevMotorPos.panAngle) {
    pan.write(motorPos.panAngle);
  }
  if (motorPos.tiltAngle != prevMotorPos.tiltAngle) {
    tilt.write(motorPos.tiltAngle);
  }
}

/*-------------- Data Aquisition (relying on PLX-DAQ)over Serial, for plotting ---------------------*/
void DAQModeSetup() {
  String TABLE_HEADER = "LABEL,Date,Time,Timer,Counter,"
                        "LightInt_South,LightInt_North,LightInt_East,LightInt_West,"
                        "Motor_Pan,Motor_Tilt,"
                        "Voltage";
  Serial.begin(9600);
  Serial.println("CLEARSHEET");
  Serial.println(TABLE_HEADER);
}

void DAQSendDataOverSerial() {
  Serial.println( (String) "DATA,DATE,TIME,TIMER," + loop_counter + "," +
                  lightIntData.S + "," + lightIntData.N + "," + lightIntData.E+"," + lightIntData.W + "," +
                  motorPos.panAngle + "," + motorPos.tiltAngle + "," + voltage + ",AUTOSCROLL_20");
}

/*-------------------------- Debug Mode (display data on Serial Monitor) ---------------------------*/
void DebugModeSetup() {
  Serial.begin(9600);
}

void DebugSendDataOverSerial() {
  // display data for debugging purposes
  Serial.println((String) "-----------Loop " + loop_counter + "-----------------");
  Serial.println("---Light Intensities (values given by the ADC)");
  Serial.println((String) "S=" + lightIntData.S + ", N=" + lightIntData.N +
                 ", E=" + lightIntData.E + ", W=" + lightIntData.W);

  Serial.println("---Motor positions: ");
  Serial.println((String) "PanAngle=" + motorPos.panAngle + ", TiltAngle=" + motorPos.tiltAngle);

  Serial.println("---Voltage: ");
  Serial.println((String) voltage + "V");
}

void debugForMode2() {
  Serial.println("---Motor positions: ");
  Serial.println((String) "PanAngle=" + motorPos.panAngle + ", TiltAngle=" + motorPos.tiltAngle);

  Serial.println("---Voltage: ");
  Serial.println((String) voltage + "V");
}

/*-------------------------- Output Data ---------------------------*/
void outputData() {
  // send data over the serial port for daq/debugging purposes
  if (DEBUG_MODE_ON) {
    DebugSendDataOverSerial();
  } else if (DAQ_MODE_ON) {
    DAQSendDataOverSerial();
  }
}
